\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% TODO: Anpassen
% Die nächsten drei Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 1: Superstar} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeamID}{00922}       % Team-ID aus dem PMS angeben
\newcommand{\TeamName}{Zweiundvierzig} % Team-Namen angeben
\newcommand{\Namen}{Franz Miltz} % Namen der Bearbeiter/-innen dieser Aufgabe angeben
 
% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Team-ID: \TeamID}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

% Für Algorithmen
\usepackage{algpseudocode}

% Für Quelltext
\usepackage{listings}
\lstset{language=Python}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  keywordstyle=\color{blue},commentstyle=\color{mygreen},
  stringstyle=\color{mymauve},rulecolor=\color{black},
  basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
  captionpos=b, % sets the caption-position to bottom
  keepspaces=true, % keeps spaces in text
  numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
  showtabs=false, stepnumber=2, tabsize=2, title=\lstname
}
\lstdefinelanguage{JavaScript}{ % JavaScript ist als einzige Sprache noch nicht vordefiniert
  keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  sensitive=true
}
% Diese beiden Pakete müssen zuletzt geladen werden
%\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}
\usepackage{csquotes}
% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Team-ID: \LARGE \TeamID \\\\
	    \LARGE Team-Name: \LARGE \TeamName \\\\
	    \LARGE Bearbeiter/-innen dieser Aufgabe: \\ 
	    \LARGE \Namen\\\\}
\date{\LARGE\today}

\begin{document}

\maketitle
\tableofcontents

\vspace{0.5cm}

\section{Lösungsidee}
Die Aufgabe und meine Lösung umfassen mehrere Teilprobleme. Das erste was sich stellt, ist der triviale Fall. Hierzu muss bestimmt werden, in welchem Winkel Lisa laufen muss, wenn sie kein Hindernis in ihrem Weg hat. Dass sie in diesem Fall einer geraden Strecke folgt ist klar, da anderenfalls ein kürzerer Weg zum Schnittpunkt mit der Stra\ss e existieren würden.\\
\indent Um die komplizierteren Fälle zu betrachten werden zwei wesentliche Schritte benötigt. Zunächst müssen alle \emph{relevanten} Punkte berachtet werden, die für die Ermittlung des optimalen Weges eine Rolle spielen. Wenn diese Punkte dann bestimmt sind, müssen in den resultierenden Graphen alle möglichen Kanten (optimalerweise mit Kantelängen) eingezeichnet werden. In diesem Graphen muss nun der Pfad gesucht werden, den Lisa gehen muss, um so spät wie möglich ihr Haus verlassen zu können.
\subsection{Freier Weg}
Wir betrachten das Dreieck $\Delta ABC$ wobei die Seite $b$ Lisas Abstand zur y-Achse und die Seite $a$ der Abstand des Schnittpunktes der beiden Wege $S$ in y-Richtung von Lisa ist. Somit ist der Abstand zwischen Lisa und dem Punkt $\sqrt{a^2 + b^2}$. Uns ist egal, wo der Bus sich im Moment befindet, weil er zwar die Zeitdifferenz am Punkt $S$ verändert, aber die Änderung in Abhängigkeit des Winkels bzw. des Verhältnisses $\frac{a}{b}$ bleibt gleich, d.h. die Position des Busses ist für die Ableitung irrelevant.\\
Somit können wir die Zeitdifferenz $\Delta t$ in Abhängigkeit des Faktors $r$ in $a=rb$ bei bestimmten Geschwindigkeiten $v_B$ und $v_L$ bestimmen:
\begin{align}
\Delta t = \frac{r\cdot b}{v_B} - \frac{\sqrt{(r^2+1)}\cdot b }{v_L}
\end{align}
Für die Ableitung gilt folglich:
\begin{align}
\frac{d}{dr}\left(\frac{r\cdot b}{v_B} - \frac{\sqrt{r^2+1}\cdot b }{v_L}\right)= \frac{b}{v_B} + \frac{b\cdot r }{v_L\sqrt{r^2+1}}
\end{align}
Nun suchen wir Extremstellen:
\begin{align}
\frac{d}{dr}\Delta t = 0 \Leftrightarrow r = \pm\frac{v_L}{\sqrt{v_B^2 - v_L^2}}
\end{align}
Da wir nur an positiven $r$ interessiert sind, vernachlässigen wir die Vorzeichen an dieser Stelle. Somit wissen wir, wie Lisa laufen muss, wenn ihr kein Hindernis im Weg ist. Den tatsächlichen Winkel auszurechnen wäre auf Grund der Modellierung, die ohne Winkel auskommt, unnötig.
\subsection{Relevante Punkte}
Ich habe bereits erwähnt, dass der Weg bei freier Strecke gradlinig verlaufen muss. Dieser Umstand gilt mehr oder weniger auch, wenn Hindernisse im Weg sind. Denn da Lisa keine Form der Trägheit hat, ist es für sie am effizientesten stets solange geradeaus zu laufen, bis sie ihre Richtung ändern kann, weil der nächste Wegpunkt in sicht ist. Das bedeutet, dass sich Lisas Pfad, abgesehen vom Schnittpunkt mit der Stra\ss e, ausschlie\ss lich aus Eckpunkten der Hindernisse zusammensetzt. Um dies etwas zu präzisieren, kann sogar gesagt werden, dass der Pfad sogar nur aus kovexen Eckpunkten der Polygone besteht. Dies kann man sich leicht erklären, indem man ein konkaves Polygon betrachtet. Zwischen zwei konvexen Ecken verläuft der kürzeste Weg nie über eine konkave Ecke. Sollte nun ein anderes Polygon diesen direkten Weg blockieren, ist auch hier die kürzeste Strecke über die konvexen Ecken jenes Polygons.\\
Wenn wir nun also versuchen alle relevanten Punkte zu finden, müssen wir alle konvexen Ecken der Polygone betrachten.
\subsection{Kanten}
Um herauszufinden, welche Punkte direkt durch eine Kante miteinander verbunden werden können, muss ein Schnittalgorithmus her. Zu die Funktionsweise dieses Algorithmus werde ich stärker in der Umsetzung thematisieren. Relevant ist im Moment, dass er existiert. Wir können also überprüfen, ob zwei Strecken in unserer Ebene sich schneiden. Somit können wir alle diejenigen Wegpunkte miteinander verbinden, zwischen denen die Strecke mit keiner Kante eines Polygons kollidiert.\\
Die Länge dieser Kante herauszufinden ist nun trivial, weil sie mit dem Satz des Pythagoras und den Koordinaten der beiden Punkte beschrieben werden kann.
\subsection{Optimaler Weg}
Es gibt viele Algorithmen, um einen optimalen Weg zwischen zwei Punkten in einem Graphen zu finden. Leider bringen uns diese Algorithmen nur etwas, wenn wir die potentiellen Punkte auf der Stra\ss e markieren, die erreichbar sind. Darauf möchte ich jedoch verzichten, weil es einen besseren Ansatz gibt. Statt die Punkte zu suchen, die wir auf der Stra\ss e optimalerweise erreichen können, schauen wir nur, welche Punkte des Graphen unter dem optimalen Winkel einen freien Weg zur Stra\ss e haben und markieren diese.\\
Beginnend bei dem Startknoten, Lisas Haus, starten wir nun unsere Suche nach dem optimalen Weg. Dabei fügen wir in jedem Schritt einer Warteschlange all jene Pfade hinzu, die aus der aktuellen Instanz entstehen können. Wir fügen dem bisher gelaufenen Pfad also alle unbesuchten Nachbarn einzeln hinzu. Die Warteschlange sortiert hierbei alle Teilpfade nach der minimalen Zeitdifferenz, für die dieser Pfad sorgen kann.\\
Diese minimale Differenz ist hierbei eine tatsächliche Untergrenze. Sie berechnet sich aus der Länge der bereits gelaufenen Strecke sowie der Länge des Weges, den Lisa wählen sollte, wenn es ab dem aktuellen Knoten kein Hindernis mehr gäbe. Damit wird klar, dass der optimale Weg genau dann gefunden wurde, wenn der letzte besuchte Knoten des obersten Teilpfades auf der Warteschlange einen freien, optimalen Weg zur Stra\ss e hat. Denn in diesem Fall wird die Untergrenze zur tatsächlichen Zeitdifferenz.\\
Wenn diese Folge von Knoten in unserem Graphen gefunden wurde, wird es mehr oder weniger trivial den Zeitpunkt zu bestimmen, an dem Lisa spätestens loslaufen muss, um den Bus zu bekommen. Dieser Zeitpunkt ist die Abfahrtzeit des Busses plus die Zeitdifferenz (die aller Wahrscheinlichkeit nach negativ ist).
\section{Umsetzung}
Ich habe das Programm auf einem Linux-System in der Programmiersprache Go implementiert. Die Wahl der Sprache hat mehrere Gründe. Einerseits ist die Sprache sehr leicht verständlich und ist daher in meinen Augen ähnlich wie Python für den BwInf sehr geeignet und andererseits ist die Sprache schnell. Zum einen lassen sich Projekte sehr schnell kompilieren und zum anderen sind sie ähnlich schnell wie solche, die in Sprachen wie C/C++ geschrieben wurden. Ein weiterer Vorteil, den ich unter Umständen ausnutzen werde ist die Tatsache, dass Go sehr gute Unterstützung für Nebenläufigkeit bereitstellt. Hinzu kommt der lobenswerte Umstand, dass Go sehr einheitlich ist. Der Quellcode wird automatisch formatiert und die Sprache zwingt mich meinen Code zu kommentieren. All diese Eigenschaften machen Go zu einer der geeignetsten Sprache für die Lösung der Probleme im Rahmen des Bundeswettbewerbs Informatik.\\
Das entstandene Programm ist eine Applikation, die aus der Command Line einen Server startet, auf den dann im Browser zugegriffen werden kann. Da es für die Lösung der Aufgabe nicht relevant ist, wie ich die Dateien einlese und wie ich meinen Output ausgebe, werde ich diese Schnittstellen nicht weiter thematisieren.\\
Was hingegen wichtig ist, ist sind die Datenstrukturen, die genutzt werden, um den Graphen zu erstellen. Hierzu gibt es vier geometrische Objekte, die im Quellcode abstrahiert werden. Diese Objekte befinden sich im \texttt{internal}-Paket des Projektes. Das kleinste Element ist ein einfacher Punkt. Dieser besteht aus zwei zwei Gleikommazahlen, den Koordinaten $X$ und $Y$.
\begin{lstlisting}[language=Go]
type Point struct {
  X, Y float64
}
\end{lstlisting}
Hinzu kommen Geraden, die in der $abc$-Form dargestellt werden:
\begin{lstlisting}[language=Go]
type Line struct {
	A, B, C float64
}
\end{lstlisting}
Es gilt also:
\begin{align}
  ax + by = c 
\end{align}
Da das Problem nahezu ausschlie\ss lich Strecken umfasst, wird auch hierfür eine Datenstruktur benötigt:
\begin{lstlisting}[language=Go]
type LineSegment struct {
	L    *Line
	A, B *Point
} 
\end{lstlisting}
Wie man sieht setzt sich eine Strecke einerseits aus den beiden Punkten zusammen, die ihr Ende bilden und andererseits aus der Geradengleichung, die den Verlauf der Strecke beschreibt.\\
Wenn man nun Polygone beschreiben will, kann man sich entscheiden, ob diese als geordnete Menge von Punkten oder von Strecken beschrieben werden. Ich habe mich für Punkte entschieden, weil die Inputdaten ebenfalls in diesem Format vorhanden sind und Strecken im Wesentlichen auch nur Paare von Punkten sind. Um die spätere Berechnungen einfacher zu machen, nehmen wir eine weitere Abstraktion vor. Die Ecken der Polygone sind nun nicht nur einfache Punkte, sondern kennen weiterhin ihre Nachbarn sowie das Polygon dem sie angehören.
\begin{lstlisting}[language=go]
type Corner struct {
	*Point
	Plygn *Polygon
	N1    *Corner
	N2    *Corner
} 
\end{lstlisting}
Damit lässt sich ein Polygon folgenderma\ss en beschreiben:
\begin{lstlisting}[language=go]
type Polygon struct {
	Corners []*Corner
	N       int
}
\end{lstlisting}
Dabei ist \texttt{Polygon.N} die Anzahl der Ecken des Polygons.\\
Nun lesen wir die Eingabedaten und konstruieren das Gelände, in dem Lisa sich bewegen muss. Dieses Gelände wird als \texttt{internal/terrain.Terrain} abstrahiert.
\begin{lstlisting}[language=go]
type Terrain struct {
	PolCnt int
	Plygns []*internal.Polygon
	Start  *internal.Point
}
\end{lstlisting}
Dabei ist \texttt{Start} der Punkt an dem Lisa zu laufen beginnt. Um aus diesem Gelände jetzt einen Graphen zu generieren, benötigen wir folgende Schritte.\\
Zunächst müssen wir nacheinander alle Ecken der Polygone ablaufen und entscheiden, ob der Punkt relevant ist. Wenn er das ist, wird er der Liste der relevanten Punkte hinzugefügt. 
\begin{lstlisting}[language=go]
pt2indx := make(map[*internal.Point]int)
indx2pt := make(map[int]*internal.Point)
pt2indx[t.Start] = 0
indx2pt[0] = t.Start
count := 1
for _, plygn := range t.Plygns {
  for _, c := range plygn.Corners {
    if !c.IsConcave() {
      indx2pt[count] = c.Point
      pt2indx[c.Point] = count
      count++
    }
  }
}
\end{lstlisting}
Wie man sieht erstellen wir zwei Maps (im Wesentlichen Hashtabellen), die einerseits Indizes auf Punkte und andererseits Punkte auf Indizes abbilden. Diesen Maps fügen wir nun zunächst Lisas Zuhause und anschließend alle konvexen Ecken der Polygone hinzu.\\
Wie finden wir heraus, ob eine Ecke konvex ist? Ganz einfach:
\begin{lstlisting}[language=go]
func (crnr *Corner) IsConcave() bool {
	a := crnr.N1.Point
	b := crnr.Point
	c := crnr.N2.Point
	return (b.X-a.X)*(c.Y-b.Y)-(b.Y-a.Y)*(c.X-b.X) < 0
}
\end{lstlisting}
\end{document}
